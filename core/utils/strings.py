# SPDX-License-Identifier: MPL-2.0
# Copyright (c) 2025 Yoham Gabriel B.

"""
String Manipulation Utilities
This module provides reusable utility functions that support various operations across the project.
It contains implementations for common tasks including:

- Cleaning and formatting filenames and paths
- String conversion and transformation

Author: Yoham Gabriel Urbine@GitHub
Email: yohamg@programmer.net
"""

__author__ = "Yoham Gabriel Urbine@GitHub"
__author_email__ = "yohamg@programmer.net"

import base64
import hashlib
import random
import re
import string
from datetime import date
from re import Pattern
from typing import Optional


def clean_filename(filename: str, extension: str = "") -> str:
    """This function handles filenames with and without extension
    and avoids breaking functions that work with filenames and paths
    without expecting a user to pass in a correct ``filename.extension`` every time.

    In case that you don't pass an extension, the function will return the filename without
    any modifications, like a "trust" mode.

    :param filename: ``str`` -> self-explanatory
    :param extension: ``str`` -> self-explanatory. Default ``""`` (Empty str)
    :return: ``str`` (New filename)
    """
    if extension == "":
        return filename
    elif not isinstance(filename, str):
        raise TypeError(f"Filename must be a string, not {type(filename)}!")
    elif not isinstance(extension, str):
        raise TypeError(f"Extension must be a string, not {type(filename)}!")

    no_dot = lambda fname: re.findall(r"\w+", fname)[0]  # noqa: E731

    if "." in list(filename):
        return (
            ".".join(
                filter(lambda lst: no_dot(extension) not in lst, filename.split("."))
            )
            + f".{no_dot(extension)}"
        )
    else:
        return f"{filename}.{no_dot(extension)}"


def match_list_single(
    hint: str | Pattern[str],
    items: list,
    ignore_case: bool = False,
    re_match: bool = False,
) -> Optional[int]:
    """Matches a single occurrence of a ``hint`` and returns its ``index`` position.

    :param hint: ``str`` pattern or word
    :param items: where to look for occurrences (list of ``str`` or ``WebElement``)
    :param ignore_case: ``True`` to disable the ``re.IGNORECASE`` flag in the Python Regex match. Default ``False``.
    :param re_match: ``True`` to enable the ``re.match`` operation for matches. Default ``False``
    :return: ``int`` or ``None`` if there is no match.
    """
    ignore_case = re.IGNORECASE if ignore_case else 0
    for item in items[:]:
        if isinstance(item, str) or isinstance(item, Pattern):
            # Item must be kept intact in case I want to look for it in the list.
            # In this case it doesn't matter, however, re.match looks for
            # matches in `inter`
            inter = item
        else:
            # in case I am passing a list of WebElement items.
            inter = item.text

        if (
            re.findall(hint, inter, flags=ignore_case)
            if not re_match
            else re.match(hint, inter, flags=ignore_case)
        ):
            return items.index(item)
        else:
            continue
    return None


def match_list_mult(
    hint: str, list_lookup: list[str], ignore_case: bool = False
) -> list[int]:
    """Matches a ``str`` within a list and returns the indexes where such matches occurred.

    :param hint: ``str`` pattern
    :param list_lookup: the list likely to contain the match.
    :param ignore_case: ``True`` to enable the ``re.IGNORECASE`` flag for matches. Default ``False``
    :return: ``list[int]`` list of matching index positions.
    """
    ignore_case = re.IGNORECASE if ignore_case else 0
    return [
        num
        for num, elem in enumerate(list_lookup)
        if re.findall(hint, elem, flags=ignore_case)
    ]


def match_list_elem_date(
    l_hints: list[str],
    lookup_list: list[str],
    ignore_case: bool = False,
    join_hints: tuple[bool, str, str] = (False, "", ""),
    strict: bool = False,
    reverse: bool = False,
) -> list[str]:
    """Finds matches, within a list of strings, and compares the dates in each of the strings to return the items
    that are associated with the latest dates; therefore, leaving out strings with the same name that do not contain
    a relevant date (strict mode). This project adopted a filename convention that places filenames, joined with
    hyphens ('-'), with a date string in ISO format to keep track of updates in files generated by other modules.
    One of our helper functions in this module returns a list of files by extension
    ``search_files_by_ext`` and I needed a way of getting the most relevant files, so that other modules can
    incorporate further functionality that can effectively select from the available filenames and work with an
    updated copy of such. This algorithm also implements a simple ``reverse`` mode, that outputs the lookup list without
    the matches; in other words, it excludes the matches if you don't want to use them in your functionality.

    For example, I have to match strings with the hints ``['foo', 'bar']`` within a list
    ``['foo-2024-11-04', 'foo-2024-11-02', 'bar-2024-10-29', 'bar-2024-09-20']`` the function will find multiple occurrences
    of the hints and for each hint in the list do the following:

    1. manipulate the hint with split and join if needed (in case there is a known pattern in place)
    2. extract dates using regular expressions and compare them to find the string related to the latest date
    3. match other strings that do not contain dates (strict mode off).

    :param l_hints: list of patterns or str that you want to match.
    :param lookup_list: list of strings to process and look for matches
    :param ignore_case: ``True`` if you want to enable the ``re.IGNORECASE`` flag in the matching process. Default ``False``
    :param join_hints: (optional) Tuple of three values:\n
           1. ``bool`` value to tell the function whether to use the values that you provided.\n
           2. `split` character because, if you want to join, you need to split in this case.\n
           3. `join` character to join your hints.\n
           -> Here is an example with the `join_hints` parameter:\n
           ``hints = ['foo bar', 'moo woo']``\n
           ``lookup_list = [foo-bar-2024-11-09, foo-bar-2024-11-02, moo-woo-2024-10-27, moo-woo-2024-10-29]``\n
           ``join_hints = (True, ' ', '-')``\n
           # This will result in 'foo-bar' and 'moo-woo' as the new hints.\n
           From here the function will extract the date and store the item the *"most up-to-date"* filename,
           leaving out older and irrelevant filenames.
           In this example, the output will be ``[foo-bar-2024-11-09, moo-woo-2024-10-29]``
    :param strict: ``True`` if you only want to match strings with "date".
           **Note that, if this is active, other strings that do not follow the convention will be left out.**
           Default ``False``.
    :param reverse: ``True`` to return a ``lookup_list`` without the matches.
    :return: ``list[str]``
    """
    up_to_date: list[str] = []
    main_matches: list[str] = []
    for hint in l_hints:
        if join_hints[0]:
            spl_hint = hint.split(join_hints[1])
            hint = join_hints[2].join(spl_hint)

        matches = match_list_mult(hint, lookup_list, ignore_case=ignore_case)

        get_match_items = [lookup_list[indx] for indx in matches]

        if reverse:
            for match in get_match_items:
                main_matches.append(match)

        date_regex = re.compile(r"(\d{2,4}-\d{1,2}-\d{1,2})")

        extract_dates = [
            date.fromisoformat(date_regex.findall(match)[0])
            for match in get_match_items
            if date_regex.findall(match)
        ]

        if extract_dates:
            max_date_items = match_list_mult(str(max(extract_dates)), get_match_items)
            for indx in max_date_items:
                up_to_date.append(get_match_items[indx])
        elif not strict:
            # If there are no dates in the item, I still want to know about it.
            # BUT only if strict mode is disabled.
            for m_item in get_match_items:
                up_to_date.append(m_item)
        else:
            continue
    if reverse:
        return [match for match in main_matches if match not in up_to_date]
    else:
        return up_to_date


def str_encode_b64(encode_str: str) -> str:
    """Encode any string by using the Base64 algorithm.

    :param encode_str: ``str`` to encode
    :return:
    """
    encode_bytes = encode_str.encode("ascii")
    b64_bytes = base64.b64encode(encode_bytes)
    return b64_bytes.decode("ascii")


def sha256_hash_generate(r_str: str) -> str:
    """Generate SHA256 hash from random string.

    :param r_str: ``str`` random string
    :return: ``str`` SHA256 hash string
    """
    return hashlib.sha256(r_str.encode()).hexdigest()


def generate_random_str(k: int) -> str:
    """Generate a random string of ASCII characters based on a sample size ``k``.

    :param k: ``int`` Number of letters per random string or "sample size"
    :return: ``str``
    """
    letters = string.ascii_letters
    random_string = "".join(random.choices(letters, k=k))
    return random_string
